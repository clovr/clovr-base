#!/usr/bin/perl

#
# Do a perl check for version >= 5.005.  See 'gpt-translate-interpreter' should you
# need to alter the invocation path to a valid perl interpreter in the GPT front-end
# programs.
#

if ( ! ( defined eval "require 5.005" ) )
{
    die "GPT requires at least Perl version 5.005";
}

my $gpath = $ENV{GPT_LOCATION};
if (!defined($gpath))
{
  $gpath = $ENV{GLOBUS_LOCATION};

}
if (!defined($gpath))
{
   die "GPT_LOCATION or GLOBUS_LOCATION needs to be set before running this script"
}

@INC = ("$gpath/lib/perl", "$gpath/lib/perl/$Config{'archname'}", @INC);

if ( ! ( defined eval "require Grid::GPT::GPTObject" ) )
{
    die("$gpath does not appear to hold a valid GPT installation\n");
}

use strict;
use Getopt::Long;

use vars qw($VERSION %ignored_dirs %ignored_scripts);


$VERSION = '0.01';

require Pod::Usage;

my ($name, $version, $gptversion,$verbose, $make_test, $help, $nocomments);

# sub pod2usage {
#   my $ex = shift;
#   print "gpt_setup -name=<Package Name> -version=<Major.Minor.Age> [-nocomments -verbose -help -v ] source_dir build_dir\n";
#   exit $ex;
# }

GetOptions( 'name=s' => \$name, 'version=s' => \$version, 
	    'tstdir' => $make_test, 'verbose=i' => \$verbose, 
            'nocomments' => \$nocomments,
	    'help' => \$help, 'v' => \$gptversion)
  or Pod::Usage::pod2usage(1);

Pod::Usage::pod2usage(0) if $help;
require Grid::GPT::GPTIdentity;
Grid::GPT::GPTIdentity::print_gpt_version() if defined $gptversion;

if (!defined($version) or !defined($name)) {
  print "ERROR: You must specify name and version\n"; 
  Pod::Usage::pod2usage(1); 
}

$version =~ /(\d+)\.(\d+)\.(\d+)/;
my ($major, $minor, $age) = ($1, $2, $3);

if (!defined ($major)) {
  print "ERROR: Version needs to be in d.d.d format\n";
  Pod::Usage::pod2usage(1);
}

my $packagedizedir = $gpath;

$packagedizedir .= '/share/globus_aclocal';

# establish stuff to be ignored by packagedize
for (@{ ['CVS', 'RCS', 'pkgdata', 'doxygen'] }) {
  $ignored_dirs{$_}++;
}

for (@{ ['config.status', 'bootstrap', 'libtool', 'configure', 'install-sh'] }) {
  $ignored_scripts{$_}++;
}


my $source_prefix = ".";
$source_prefix = $ARGV[0] if(defined($ARGV[0]));
my $build_prefix = $source_prefix;
$build_prefix = $ARGV[1] if(defined($ARGV[1]));
$source_prefix =~ s/\/+$//g;
$build_prefix =~ s/\/+$//g;

my @ac_outputs;
my $ac_headers = "";
my $pkglibs = "";
my @doxygen_src_dirs;


# generating Makefile.am's. 
my @subdirs = ("pkgdata", "doxygen");
process_dir(suffix => "", 
            subdirs => \@subdirs, 
            frg => "$packagedizedir/top_Makefile_am.frg");

my %targets;

# do the right thing for doxygen

if (! -d "$source_prefix/doxygen") {
   mkdir("$source_prefix/doxygen", 0755) || 
      die "Unable to create doxygen directory\n";
}

push @ac_outputs, "doxygen/Makefile";
push @ac_outputs, "doxygen/Doxyfile";
push @ac_outputs, "doxygen/Doxyfile-internal";

for(0..$#doxygen_src_dirs) 
{
   $doxygen_src_dirs[$_] = " ../$doxygen_src_dirs[$_] "
}

# generate doxygen specific configure.in substitutions

$targets{'PACKAGE_NAME'} = "\"$name\"";

$targets{'DOXYGEN_SRC_DIRS'} = "\"@doxygen_src_dirs\"";

# generate configure.in

my $am_config_header = "";
if ($ac_headers ne "") {
  $am_config_header = "AM_CONFIG_HEADER($ac_headers)";
}

my $ac_outputs_line = join("\n\t",@ac_outputs);

($targets{'AM_CONFIG_HEADER'}, $targets{'AC_OUTPUT'})= 
  ($am_config_header, $ac_outputs_line);

transform_file("$packagedizedir/configure_in.frg", "$source_prefix/configure.in", 
               \%targets);
($targets{'AM_CONFIG_HEADER'},$targets{'AC_OUTPUT'} )= (undef, undef);

# Create bootstrap script.
install("$packagedizedir/bootstrap.frg",  "$source_prefix/bootstrap", 755);

# generate pkgdata directory
if (! -d "$source_prefix/pkgdata") {
my $result =`mkdir $source_prefix/pkgdata`;
}

($targets{'PACKAGE'}, $targets{'MAJOR'}, $targets{'MINOR'}, $targets{'AGE'}, 
 $targets{'PKGLIBS'}) = ($name, $major, $minor, $age, $pkglibs);

transform_file("$packagedizedir/pkg_data_src_gpt_in.frg", 
               "$source_prefix/pkgdata/pkg_data_src.gpt.in", 
               \%targets);

($targets{'PACKAGE'}, $targets{'MAJOR'}, $targets{'MINOR'}, $targets{'AGE'}) = 
  (undef, undef, undef, undef);



sub process_dir {
  my (%args) = @_;
  my $suffix = $args{'suffix'};
  my $prog_target = 'bin_';

  # determine if $suffix is a test directory
  
  if ($suffix =~ /tests?$/ and $make_test) {
    $prog_target = 'test_';
  }
  my $srcdir = qq($source_prefix/$suffix);  
  my $builddir = qq($build_prefix/$suffix);

  # strip trailing slashes

  $srcdir =~ s/\/+$//;
  $builddir =~ s/\/+$//;
  
#  print "process_dir extracting from $srcdir and $builddir\n";
  my $subdirs_r = extract_files($srcdir, 'subdirs');
  my $sources_r = extract_files($srcdir, 'expression',qr/\.[cChH]$/);
  my $libraries_r = extract_files($builddir, 'expression',qr/\.(so|a|la)$/);
  my $initialized_r = extract_files($srcdir, 'expression',qr/\.in$/);
  my $programs_r =  extract_files($builddir, 'executables');
  my $man_r = extract_files($srcdir, 'expression',qr/\.\d$/);
  my $headers_r = extract_files($srcdir, 'expression',qr/\.h(?:\.in)?$/);

  my $valid = 0;
  my @subdirs;
  my @sources = (@$sources_r);
  my @libraries = (@$libraries_r);
  my @programs;
  my @scripts;
  my @man = (@$man_r);
  my @headers;

# This section filters out some files 

  if (@$subdirs_r > 0) {
    for (@$subdirs_r) {
      if (!defined($ignored_dirs{$_})) {
	push @subdirs, $_;
      }
    }
  }
  my $slashed_suffix = $suffix;
  if ($slashed_suffix ne "") {
    $slashed_suffix .= '/';
  }
  if (@$initialized_r > 0) {
    for (@$initialized_r) {
      if (!/Makefile.in/ && !/configure.in/) {
	s/\.in//;
	my $rootname = $_;
        if ( /\.h$/) {
          print "Found autoconf'ed header $_\n";
          $ac_headers .=" $_:${slashed_suffix}$rootname";
          push @headers, $rootname;
        } else {
          print "Found autoconf'ed file $_\n";
          push @ac_outputs, "${slashed_suffix}$rootname";
        }
      }
    }
  }
  
  if (@$programs_r > 0) {
    for (@$programs_r) {
#      print "Examining $_\n";
      if (-T "$builddir/$_") {
	if (!defined($ignored_scripts{$_})) {
#	  print "FOUND A SCRIPT $_\n";
	  push @scripts, $_;
	}
      }
      elsif (-f "$builddir/$_"){
#	print "FOUND A PROGRAM $_\n";
	push @programs, $_;
      }
    }
  }

  if (@$headers_r > 0) {
    for (@$headers_r) {
      if (! /(?:ac)?config\.h/) {
	push @headers, $_;
      }
    }
  }

  my %targets;
  $targets{'TARGETS'} = "";

# Put together a Makefile.am
  my @mysubdirs = @subdirs;
  if(defined($args{'subdirs'}))
  {
     @mysubdirs = (@mysubdirs, @{$args{'subdirs'}});
  }

  my %comments = (
                  "SUBDIRS", 
                  "# SUBDIRS is an automake macro which contains 
# the list of subdirectories that have Makefile.am's\n",
                  "Sources",
                  "# Sources contains all of the source files in the directory.
# Header files are included because automake will generate dependency targets 
# for them and include them in a source distribution.
#
# If this directory builds multiple programs or libraries than these sources
# will need to be seperated into seperate macros.\n",
                 "INCLUDES",
                  "# INCLUDES is an automake macro which contains 
# the include directives (-I..) for the compiler.
#
# GPT_INCLUDES contains the include directives generated by GPT 
# from the dependent packages.\n",
                  "Scripts",
                  "# Scripts contains all of the scripts in this directory\n",
                  "TESTS",
                  "# TESTS is an automake that contains a list 
# of tests to run during a \"make check\"
# These test can be either be programs or scripts.
# All of the test are expected to return 0 for pass and non-zero for a fail\n",
                  "SCRIPTS",
                  "# $ {prog_target}SCRIPTS is an autmake macro that contains 
# a list of scripts to be installed in a certain directory.
# bin is \$prefix/bin
# noinst means that the scripts are not installed in any directory.
# You can also use the following:
# sbin is \$prefix/sbin
# libexec is \$prefix/libexec
# You can also use any directory defined by a macro of the form
# \<directory_name\>dir\n",
                  "EXTRA_DIST",
                  "# EXTRA_DIST is used to include files in 
# a source distribution that automake fails to detect.\n",
                  "MANS",
                  "# man_MANS is an automake macro which contains a list of man files to install.
# automake will install the files into the man directory indicated by the file's extension.
# For example, file foo.3 will be installed \$prefix/man/man3",
                  "HEADERS",
                  "# include_HEADERS is an automake macro which contains 
# a list of header files that are to be installed in \$prefix/include\n",
                  "LTLIBRARIES",
                  "# lib_LTLIBRARIES is an automake macro which contains
# a list of libtool libraries that are to be installed in \$prefix/lib\n",
                  "SOURCES",
                  "# _SOURCES is an automake macro which contains
# a list of sources needed to compile the library.\n",
                  "LDFLAGS",
                  "# _LDFLAGS is an automake macro which contains
# directives to the linker add before the list of objects and libraries.
# 
# GPT_LDFLAGS is a macro that contains the linker directives GPT generated 
# from the dependent packages\n",
                  "LIBADD",
"# _LIBADD is an automake macro which contains
# directives to the linker added after the list of objects.  
# LIBADD is specific for linking libraries
# 
# GPT_LIB_LINKS is a macro that contains the linker directives GPT generated 
# from the dependent packages\n",
                  "LDADD",
"# _LDADD is an automake macro which contains
# directives to the linker added after the list of objects.  
# LDADD is specific for linking programs
# 
# GPT_PGM_LINKS is a macro that contains the linker directives GPT generated 
# from the dependent packages\n",
                  "PROGRAMS",
                  "# bin_PROGRAMS is an automake macro which contains
# a list of programs that are to be installed in a certain directory.
# bin is \$prefix/bin
# noinst means that the programs are not installed in any directory.
# You can also use the following:
# sbin is \$prefix/sbin
# libexec is \$prefix/libexec
# You can also use any directory defined by a macro of the form 
# \<directory_name\>dir\n",
                 );
  
  if (@mysubdirs > 0) {
    $targets{'TARGETS'} .=  $comments{'SUBDIRS'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "SUBDIRS=";
    for (@mysubdirs) {
      if ($_ ne 'CVS') {
      $targets{'TARGETS'} .=  " \\\n\t$_";
      }
    }
    $targets{'TARGETS'} .=  "\n\n";
    $valid = 1;
  }
  
  if (@sources  > 0) {
    my $relsrcdir = $srcdir;
    $relsrcdir =~ s!^$source_prefix/*!!;
    push @doxygen_src_dirs, $relsrcdir;
    $targets{'TARGETS'} .=  $comments{'Sources'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "Sources=";
    for (@sources) {
      $targets{'TARGETS'} .=  " \\\n\t$_";
    }
    $targets{'TARGETS'} .=  "\n\n";
    $targets{'TARGETS'} .=  $comments{'INCLUDES'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "INCLUDES += \$\(GPT_INCLUDES\)\n\n";

    $valid = 1;
  }
  if (@scripts > 0) {
    $targets{'TARGETS'} .=  $comments{'Scripts'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "Scripts=";
    for (@scripts) {
      $targets{'TARGETS'} .=  " \\\n\t$_";
    }
    $targets{'TARGETS'} .=  "\n\n";

    $targets{'TARGETS'} .=  $comments{'SCRIPTS'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "$ {prog_target}SCRIPTS = \$\(Scripts\)\n";
    $targets{'TARGETS'} .=  $comments{'EXTRA_DIST'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "EXTRA_DIST = \$\(Scripts\)\n";
    $valid = 1;

  }

  if (@man > 0) {
    $targets{'TARGETS'} .=  $comments{'MANS'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "man_MANS=";
    for (@man) {
      $targets{'TARGETS'} .=  " \\\n\t$_";
    }
    $targets{'TARGETS'} .=  "\n\n";
    $targets{'TARGETS'} .=  $comments{'EXTRA_DIST'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "EXTRA_DIST = \$\(man_MANS\)\n";
    $valid = 1;

  }

  if (@headers > 0) {
    $targets{'TARGETS'} .=  $comments{'HEADERS'} if ! defined $nocomments;
    $targets{'TARGETS'} .=  "include_HEADERS=";
    for (@headers) {
      if ($_ ne 'CVS') {
      $targets{'TARGETS'} .=  " \\\n\t$_";
      }
    }
    $targets{'TARGETS'} .=  "\n\n";
    $valid = 1;
  }

  if (!$valid) {
    print "WARNING: Makefile.am not created for $srcdir\n" if defined $verbose;
    return;
  }
  
  if (@libraries > 0) {
    my $made_comment;  
    for (@libraries) {
      my $ltl = $_;
      my $rootname = $_;
      $ltl =~ s/\.(so|a)$/_\$(GLOBUS_FLAVOR_NAME)\.la/g;
      my $target = $ltl;
      $target =~ s/\W/_/g;
      $rootname =~ s/\.(so|a)$//g;
      $rootname =~ s/^\s*lib//g;
      $pkglibs .= " -l$ {rootname}";
      $targets{'TARGETS'} .=  $comments{'LTLIBRARIES'} if ! defined $nocomments;
      $targets{'TARGETS'} .=  "lib_LTLIBRARIES = $ltl\n\n";
      $targets{'TARGETS'} .=  $comments{'SOURCES'} if ! defined $nocomments;
      $targets{'TARGETS'} .=  "$ {target}_SOURCES = \$\(Sources\)\n\n";
      $targets{'TARGETS'} .=  $comments{'LDFLAGS'} if ! defined $nocomments;
      $targets{'TARGETS'} .=  "$ {target}_LDFLAGS = \$\(GPT_LDFLAGS\)\n\n";
      $targets{'TARGETS'} .=  $comments{'LIBADD'} if ! defined $nocomments;
      $targets{'TARGETS'} .=  "$ {target}_LIBADD = \$\(GPT_LIB_LINKS\)\n\n";
    }
  }
  
  if (@programs > 0) {
    my ($programline, $compilelines, $testline) = 
      ("$ {prog_target}PROGRAMS= ",'','TESTS = ');
    $programline = $comments{'PROGRAMS'} . $programline if ! defined $nocomments;
    $testline = $comments{'TESTS'} . $testline if ! defined $nocomments;
    my $made_comment;  
    for (@programs) {
      my $target = $_;
      $target =~ s/\W/_/g;
      $programline .= "\\\n\t$_ ";
      $testline .= "\\\n\t$_ ";
      $compilelines .=  $comments{'SOURCES'} if ! defined $nocomments;
      $compilelines .= "$ {target}_SOURCES = \$\(Sources\)\n";
      $compilelines .=  $comments{'LDFLAGS'} if ! defined $nocomments;
      $compilelines .=  "$ {target}_LDFLAGS = \$\(GPT_LDFLAGS\)\n\n";
      $compilelines .=  $comments{'LDADD'} if ! defined $nocomments;
      $compilelines .=  "$ {target}_LDADD = \$\(GPT_PGM_LINKS\)\n\n";
    }
    $programline .= "\n\n";
    $testline .= "\n\n";
    $targets{'TARGETS'} .=  $programline;
    $targets{'TARGETS'} .=  $compilelines;
  }

  my $makefile_frg = "$packagedizedir/Makefile_am.frg";
  $makefile_frg = $args{'frg'} if defined $args{'frg'};

  transform_file($makefile_frg, 
                 "$srcdir/Makefile.am", 
                 \%targets);

  push @ac_outputs, "$ {slashed_suffix}Makefile";

  if (@subdirs > 0) {
    for (@subdirs) {
      if ($_ ne 'CVS') {
	process_dir(suffix => "$ {slashed_suffix}$_");
      }
    }
  }
    
}

sub transform_file {
  my ($template, $outname, $substitutions) = @_;

  if ( -f "$outname") {
    if (! -f "$outname.orig") {
      print "WARNING: $outname already exists. Moved to $outname.orig\n" if defined $verbose;
      my $result =`mv $outname $outname.orig`;
    }
  }
  open (TEMPLATE, "$template");
  open (OUT, ">$outname");
  
  while (<TEMPLATE>) {
    for my $t (sort keys %$substitutions) {
      my $expr = "XXX_$ {t}_XXX";
      s/$expr/$substitutions->{$t}/g;
    }
    print OUT $_;
  }

  close TEMPLATE;
  close OUT;
  
}

sub extract_files {
  my ($directory, $type, $expression) = (shift, shift, shift);
#  print "extracting from $directory\n";
  opendir(DIR, $directory) or do { 
    print "WARNING: directory \"$directory\" could not be opened!\n" if defined $verbose;
    return [];
  };
  my @file_list;
  {
    $type eq 'subdirs' and do { 
      # HINT the following is executed backwards.  IOW readdir is executed first.
      # HINT The statements process a list similar to bash's pipe symble.
      # HINT $_ contains the result of the previous statement
      @file_list =
	map { $_->[0] } # Form a list of names without paths.
      grep { -d $_->[1] } # extract the directories using the second array element.
      map { [ $_, "$directory/$_" ] } # form anonymous array [ name, pathname ] because 
      # readdir strips the path from the bname
      grep { ! /^\.\.?$/ } # remove the current directory and its parent 
      readdir(DIR); #read all of the filenames in the directory
    };

    $type eq 'executables' and do { 
      # HINT the following is executed backwards.  IOW readdir is executed first.
      # HINT The statements process a list similar to bash's pipe symble.
      # HINT $_ contains the result of the previous statement
      @file_list =
	map { $_->[0] } # Form a list of names without paths.
      grep { -x $_->[1] } # extract the directories using the second array element.
      map { [ $_, "$directory/$_" ] } # form anonymous array [ name, pathname ] because 
      # readdir strips the path from the bname
      grep { ! /^\.\.?$/ } # remove the current directory and its parent 
      readdir(DIR); #read all of the filenames in the directory
    };

    $type eq 'expression' and do {
      defined($expression) or die "CODING: regular expression not defined\n";
      # HINT the following is executed backwards.  IOW readdir is executed first.
      # HINT The statements process a list similar to bash's pipe symble.
      # HINT $_ contains the result of the previous statement
      @file_list =
	map { $_->[0] } # Form a list of names without paths.
      grep { $_->[0] =~ /$expression/ } # extract the directories using the second array element.
      map { [ $_, "$directory/$_" ] } # form anonymous array [ name, pathname ] because 
      # readdir strips the path from the bname
      grep { ! /^\.\.?$/ } # remove the current directory and its parent 
      readdir(DIR); #read all of the filenames in the directory
    };


}
#  print "$expression, @file_list\n";
  closedir(DIR);
  return \@file_list;
}

sub usage {
  my $msg = shift;
  print "ERROR: $msg\n";
  die "USAGE: packagedize [-t] name version [directory_containing_source_code] \
[build_directory]
       -t  create make test target\n";
}

sub my_prefix {
  use Env;
  my $name = shift;

  if ($0 =~ /(.+)\/bin\/$name/) {
    my $result = $1;
    return $result;
  }
  
  my @path_list = split(/:/, $PATH);
  
  for my $path(@path_list) {
    if (-x "$path/$name") {
      $path =~ s/\/bin//;
      return $path;
    }
  }

}

sub install 
{
   use File::Copy;
   my $src = shift;
   my $dest = shift;
   my $mode = shift;

   copy($src, $dest) || die "Failed to copy $src to $dest\n";
   chmod($mode, $dest) || die "Failed to change $dest to mode $mode\n";
}


=head1 NAME

B<gpt_setup> - Create automake and autoconf files to convert
software into a package

=head1 SYNOPSIS

gpt_setup name version [directory_containing_source_code] [build_directory]

=head1 DESCRIPTION

B<gpt_setup> creates Makefile.am files and a configure.in file as well
as other stuff that is used to convert a software distribution into a
globus package.  I<name> is the name of the package. I<version> is the
version of the package.  I<directory_containing_source_code> is the
top source directory for the distribution (the default is the current
directory).  I<build_directory> is the top level directory containing
the resulting binaries (default is the source directory).  The
resulting build depends on other files from the globus packaging tools
(GPT) as well as the globus_core package.  B<NOTE> that the files that
gpt_setup creates need to be edited by hand in order for the packaging
to be complete. The idea behind gpt_setup is simple; "It is easier to
edit than to create.".

=head1 Description of the Files that B<gpt_setup> Creates

=over 4

=item B<Makefile.am>.  B<gpt_setup> creates a Makefile.am in the top
level directory and every subdirectory except for those called CVS or
RCS.  The Makefile.am files contain a list of sources, subdirectories,
libraries, programs, and scripts.  All libraries will be built as
libtool libraries.  B<NOTE> that all of the sources found will be
included in all of the targets found.  All libraries and executables
have flags from the autoconf variables GPT_INCLUDES, GPT_CFLAGS,
GPT_LDFLAGS, and GPT_LIBS added to them.  All of the Makefiles contain
directives to include files from globus_core that contain standard
make targets and rules.

=item B<configure.in> B<gpt_setup> creates a top level configure.in
containing the standard GLOBUS_* macros from globus_core. The script
detects the occurance of *.in files and headers and adds them to
AM_CONFIG_HEADER and AC_OUTPUT.

=item B<bootstrap> B<gpt_setup> creates a top level bootstrap script
which is used to invoke aclocal, automake, autoheader, and autoconf in
the correct order.

=item B<pkgdata> B<gpt_setup> creates a pkgdata directory that contains the following:

=over 4

=item B<pkg_data_src.gpt.in> is a file that contains the packaging
metadata for the newly created package.  B<gpt_setup> inserts the name
and version of the package as well as a list of all of the libraries
that the package provides.

=item B<MyFilelists.pm> is a perl module that is used by
B<gpt_sort_file_list> to sort the installed files from the source
package into binary packages.  The module can be modified to take care
of special files.

=item B<Makefile.am> is a makefile that assembles the filelists and
packaging data into the various files.

=back

=back

=head1 Post gpt_setup Tasks (What is Left to the Developer)


B<gpt_setup> does not do everything that is needed to compile a
package.  Some tasks need a developer's touch.  Here is a checklist of
tasks that may need to be done by hand:

=over 4

=item  Dependencies need to be added to pkgdata/pkg_data_src.gpt.in

You can use the GUI tool B<gpt_edit> or edit the file by hand.  The
format is explained in B<Package>, B<SourceDependency>, and
B<Version>.

=item  Build Environment flags need to be added to configure.in

Use the autoconf macros GPT_SET_CFLAGS, GPT_SET_INCLUDES, GPT_SET_LIBS
pass build environment flags to both the Makefiles and the packaging
metadata. With the exception of GPT_SET_CFLAGS, these flags will be
included in the packaging metadata and used when packages using this
package are built.  See B<Package> for details on the build
environment metadata.

=item Source needs to be assigned to programs and libraries in the Makefile.am's.

B<gpt_edit> automatically assigns all source found in a directory to
all of the targets found in a directory.  For example:

  Sources = \
         foo.c \
         foo.h \
         fee.c \
         fee.h

  bin_programs = foo fee

  foo_SOURCES = $(Sources)
  fee_SOURCES = $(Sources)

As you can see both programs fee and foo wind up being built with the
same set of sources.  This is of course wrong and needs to be
corrected for every directory where more than one program or
library is built.

=item Autoconf defines need to be tested for

Use B<gpt_undefines> to identify all of the preprocesser macros that
are used in the source code which are not defined internally.  This
list will highlight the autoconf tests that need to be added to the
configure.in script. 

=back

=head1 SEE ALSO

gpt_edit(1) gpt_undefines(1) automake(1) autoconf(1) Package(3) Version(3) SourceDependency(3)

=head1 AUTHOR

Michael Bletzinger E<lt>mbletzin.ncsa.uiuc.eduE<gt> and Eric Blau
E<lt>eblau.ncsa.uiuc.eduE<gt>

=cut
