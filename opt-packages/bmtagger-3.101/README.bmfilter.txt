
BMfilter: Best Match filter for marking human reads in metagenomics datasets

                                NCBI/NLM/NIH

                                23 July 2010

                               Version 3.101

   Analyze input reads with heuristics by matches of words to words of
   the reference genome and prepare files that may be used for further
   analysis

  Table of Contents

     * [1]Synopsis 
     * [2]Description 
     * [3]Options 
          + [4]General options 
          + [5]Options controlling input 
          + [6]Options to filter input 
          + [7]Options controlling output 
          + [8]Heuristics parameters 
     * [9]Output 
     * [10]Return codes 

Synopsis

   bmfilter [-q 0|1] [-1 readfile] [-2 matefile] [-A SRArun]
   [-b bitmapfile] [-M] [-i SRAspots] [-a maxAmb] [-l] [-N Nwin]
   [-Q minqual] [-o outbasename] [-I] [-TPRz] [-F complexity]
   [-L shortseqlen] [-n tinyseqlen] [-c choplen] [-s chopstep]
   [sra-options] [heur-options]

   See section ``Options'' for more details.

Description

   For each input short read, bmfilter performs analysis and marks the
   read as:
    1. strongly resembling a read coming from reference genome (e.g.
       human),
    2. having no similarity to the reference genome (appears to be
       foreign),
    3. being in grey zone (maybe reference, maybe foreign) and further
       analysis is necessary.

   Decision is made based on statistics of how query sequence words match
   reference words. Reference genome is represented as bitmap file
   generated by bmtool from reference sequence data.

   On input, bmfilter may take fasta or fastq files, or it may read data
   directly from SRA (if compiled with SRA toolkit and if data are
   organized according to SRA specifications).

   Output of bmfilter may include tag file indicating one of the three
   decisions for each read, fasta files for reads requiring further
   analysis, and file showing intermediate word match maps and statistics
   for each read (say, for tuning heuristics parameters).

   There is bmtagger.sh script which implements full analysis cycle
   including post-processing and temporary files handling.

Options

   Options starting with --sra-* and their short versions are available
   only if bmfilter is compiled with SRA toolkit.

    General options

   --help
   -h
          Print help and effective values of arguments and exit with
          error code 0
   --version
   -V
          Print version end exit with error code 0

    Options controlling input

   --quality-channels=0|1
   -q 0|1
          Number of quality channels for reads (0|1)
   --read-1=filename
   -1 filename
          Fasta or fastq (for -q1) file with reads, may be repeated for
          analyzing multiple files in one run
   --read-2=filename
   -2 filename
          Fasta or fastq (for -q1) file with read pair mates, if used
          should be repeated as many times as -1 is
   --word-bitmask=filename
   -b filename
          Word bitmask file (may be repeated). The file may be generated
          from reference fasta of blastdb file by bmtool.
   --use-mmap
   -M
          Use mmap to access word bitmask (slow unless used for few
          reads -- intended for debugging)
   --accession=SRArun
   -A SRArun
          SRA accession to process (may be repeated)
   --spot-id=value
   -i value
          SRA spot-ids to process (may be repeated)

    Options to filter input

   --max-ambiguities=value
   -a value
          Maximal number of ambiguities per word
   --clip-lowercase
   -l
          Should lowercase head and tail of each read be clipped
   --clip-N-win=value
   -N value
          Clip sequence head or tail as long as it has at least one N per
          this long window
   --clip-quality=value
   -Q value
          Clip sequence head or tail with quality lower then this (for
          fastq input)
   --sra-filter-bad
          Don't process reads marked as bad in SRA
   --sra-filter-cond
          Don't process reads marked as conditional in SRA
   --sra-filter-human
          Don't process reads marked as human in SRA

    Options controlling output

   --output=basename
   -o basename
          Output files base name (suffixes will be added to it)
   --spot-id-only
   -I
          Don't use prefix `accession.' for output (only available with
          single SRA accession)
   --sra-tag-filtered
          Tag SRA-filtered hits as human
   --dump-as-fasta
          Write input reads to output fasta .fa file
   --sra-use-fastq-reader
          Use FastqReader from SRA toolkit
   --sra-read-clipinfo
          Read clip info columns (not with FastqReader)
   --tag
   -T
          Produce .tag file which contains two columns: read ID and tag
          value that is one of 'H' (for human), 'F' (for foreign), or 'U'
          (for uncertain)
   --post
   -P
          Produce .short?.fa and .long?.fa files to which uncertain reads
          will be written (see also --short-seq)
   --report
   -R
          Produce .report file which will contain maps of read words --
          are they present in reference, and some stats; may be useful to
          tune heuristics
   --post-clipped
   -z
          Put clipped versions of sequences to output .short?.fa and
          .long?.fa files; unclipped versions are posted otherwise
   --post-complexity=value
   -F value
          Set complexity filter cutoff for post-processing
          (low-complexity sequences will not appear in .short?.fa or
          .long?.fa)
   --short-seq=length
   -L length
          Set sequence length to consider it as short for postprocessing
   --no-post-len=length
   -n length
          Set longest sequence length to ignore postprocessing, these
          short and shorter will not appear in .short?.fa or .long?.fa
          files)
   --chop-length=length
   -c length
          Sequences will be chopped to pieces of at most this length in
          .short?.fa files, all pieces will have same ID
   --chop-step=step
   -s step
          Pieces of the chopped short sequences will be shifted this much
          to cover all original sequence, except for the last which will
          be at the end of the original sequence

    Heuristics parameters

   --heur-min-words=value
          Set minimal word count to apply heuristics; otherwise sequence
          is considered as ``uncertain''
   --heur-many-words=value
          Set number of good words which switches watermarks (should
          values --heur-*-long-pct or --heur-*-short-pct be used for the
          sequence)
   --heur-count-long-pct=min:max
          Set watermarks for matched word count for long sequences, int %
          of good words
   --heur-count-short-pct=min:max
          Set watermarks for matched word count for short sequences, int
          % of good words
   --heur-run-long-pct=min:max
          Set watermarks for longest match run for long sequences, int %
          of good words
   --heur-run-short-pct=min:max
          Set watermarks for longest match run for short sequences, int %
          of good words
   --heur-negligible-length=value
          Set cutoff for sequences to consider - these and shorter (after
          clipping) will be marked as foreign

Output

   Output *.tag file contains two columns: read ID (or spot ID if data
   are read from SRA and --spot-id-only is used) and a letter indicating
   decision made: `H' for Human (matches genome), 'F' for Foreign (no
   match), or 'U' for Uncertain (needs farther analysis with external
   tools).

   Output *.short?.fa and *.long?.fa are fasta files which include only
   reads marked as 'U' in *.tag file. Files *.short?.fa may contain
   multiple sequences with same ID.

   File *.report has first line with columns' names. File is intended for
   research, contains some internal values and its format may change in
   future versions.

Return codes

   On error bmfilter returns non-zero code, on success it returns 0.

