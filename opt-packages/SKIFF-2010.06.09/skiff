#!/usr/bin/perl
#*********************************************************************
#  skiff.pl*
#  author: james robert white, james.dna.white@gmail.com
#  created: June 9, 2010

#  *Skiff is a program designed to create gorgeous clustering
#  figures by calling the gplots package in R. 
#  We'll assume for now that the matrix is consistent with
#  dimensions 100x100 or less. 
#*********************************************************************
use POSIX qw(ceil floor);
use Data::Dumper;
use Getopt::Std;
use warnings;
#*********************************************************************

use vars qw/$opt_F $opt_P/;
getopts("F:P:");
my $usage = 
".USAGE.   
./skiff -F <tab delimited matrix> -P <prefix>

.DESCRIPTION.
Skiff is a program designed to create clustering figures from a
standard matrix input using the R package gplots. The output figure will only support up to 
100 rows and 100 columns.

.OPTIONS.
  -F tab delimited matrix file\
  -P output prefix\

.KEYWORDS.
R, clustering, hierarchical clustering, heatmap, visualization
\n";

die $usage unless defined $opt_F
              and defined $opt_P;

my $matrixfile = $opt_F;
my $prefix     = $opt_P;


# first sanity check the file, make sure 
# 1. the names are good
# 2. the tab delimited format works
# 3. there aren't too many features for the visualization
# 4. there aren't too many samples for the visualization
# 5. the elements are integers and not something else

my $numsamples    = 0;
my $numfeatures   = 0;
my $numheadtitles = 0;
print "Performing sanity check of matrix file...\n";
open IN, "$matrixfile" or die "Cannot open your matrix file: $matrixfile!!\nGoodbye.\n";
my $ck = 0;
my $row = 1;
while(<IN>){
  chomp($_);
  my @A = split "\t", $_;
  if ($ck == 0){
    if ($A[0] ne ""){
      die "In your matrix file, the first element of the header row must be blank.\nGoodbye.\n";
    }
    $numheadtitles = $#A;
    for my $i (1 .. $#A){
      if (length($A[$i]) > 20){
        print "*Warning* Column $i has an oftly long header title...\n";
      }
    }
    $ck++; # done with the header line
    next;
  }else{
    if ($#A != $numheadtitles){
      die "*Warning* Matrix is inconsistent @ row $row ...\nGoodbye.\n";
    }
    if (length($A[0]) > 30){
      print "*Warning* Row $row has an oftly long feature name...\n";
    }
    for my $i (1 .. $#A){ # for each element in this row
      if ($A[$i] !~ /^\s*[\+\-]?\d+\s*$/){
        die "*Warning* Matrix is inconsistent @ row $row ...\nGoodbye.\n";
      }
      if ($A[$i] < 0){
        die "*Warning* Row $row has a negative number in it...\nGoodbye.\n";
      }
      if ($A[$i] < 0){
        die "*Warning* Row $row has a negative number in it...\nGoodbye.\n";
      }
    }
    $row++;
  }  
}
close IN;



$numfeatures = $row-1;
$numsamples  = $numheadtitles;

if ($numsamples == 1){
  print "Cannot cluster on one sample.\nGoodbye.\n";
  exit;
}

print 
"\n**Sanity check passed:
Filename: $matrixfile
Total number of features (rows): $numfeatures 
Total number of samples (columns): $numsamples
\n";

print "\n**Calling R to create figure...\n";
open OUT, ">$prefix\.in" or die "Can't open temp file $prefix.in!\n";
my $infile = $matrixfile; 
my $outfile = "$prefix.pdf";
print OUT 
"jrwHClust <- function(infile, outfile){

  library(\"gplots\")
  library(\"RColorBrewer\")
   
  Counts <- read.table(infile, header = TRUE, sep = \"\t\");
  A <- Counts[2:ncol(Counts)];
  nrows = nrow(A);
  ncols = ncol(A);
  C <- array(0, dim=c(nrows,ncols));
  for (i in 1:nrows){
    for (j in 1:ncols){
          C[i,j] = A[i,j];
        }
  }
  samp_names <- names(Counts);
  colnames(C) <- samp_names[2:length(samp_names)];
  rownames(C) <- Counts[,1];
    
  
  Cnormed <- array(0, dim=c(nrows,ncols));
  for (i in 1:nrows){
    for (j in 1:ncols){
          if (C[i,j] > 0){
            Cnormed[i,j] = log10((C[i,j])/sum(C[,j]));
          }else{
            Cnormed[i,j] = 2
          }
    }
  }
  
  minimumval = min(Cnormed)
  for (i in 1:nrows){
    for (j in 1:ncols){
          if (Cnormed[i,j] > 0){
                Cnormed[i,j] = minimumval - 0.001;
          }
        }
   }

  print(Cnormed)
  colnames(Cnormed) <- colnames(C);
  rownames(Cnormed) <- rownames(C);
  reds = rev(rainbow(200))[1:10];
  COLORS = c(rainbow(200)[32:200],reds);
  pdf(outfile);
  CR = NULL;
  CC = NULL;
  if (nrows > 50){
    CR = 0.4;
  }
  if (ncols > 50){
    CC = 0.4;
  }
  if (nrows > 120){
    CR = 0.2;
  }
  if (ncols > 120){
    CC = 0.2;
  }
  sw1 = 0.01/nrows;
  sw2 = 0.01/ncols;
  par(lwd = 2, omi=c(0.5, 0.5, 0.5, 0.5));
  if(nrows > 80 || ncols > 80){
    heatmap.2(Cnormed, col=COLORS, trace = \"none\", density.info=\"none\", keysize = 1.0, symbreaks=FALSE, symkey=FALSE, cexRow=CR, cexCol=CC, lmat=rbind(c(0, 3, 4), c(2,1,0)), lwid=c(1, 4, 1.2), lhei=c(1,4));
  }else{
    heatmap.2(Cnormed, col=COLORS, trace = \"none\", density.info=\"none\", keysize = 1.0, symbreaks=FALSE, symkey=FALSE, colsep=c(1:ncols), rowsep=c(1:nrows), cexRow=CR, cexCol=CC, sepwidth=c(sw1,sw2), lmat=rbind(c(0, 3, 4), c(2,1,0)), lwid=c(1, 4, 1.2), lhei=c(1,4));
  }
  dev.off()
}

jrwHClust(\"$infile\", \"$outfile\")\n";
close OUT;

#  run R batch template
#********************************************************************
system("R CMD BATCH $prefix\.in $prefix\.out"); 
#system("rm $prefix\.in $prefix\.out");

